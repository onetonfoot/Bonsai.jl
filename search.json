[
  {
    "objectID": "middleware.html",
    "href": "middleware.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Middleware\nMiddleware is a function of the form f(stream::HTTP.Stream, next), where next is the following handler/middleware in the list. It’s called in the order it was added, with the matching handler (if any) called last. By default app.middleware will run on all request methods however you can specify a specific method with app.middleware.get Bellow are examples of common usecases for middleware\n\n\nLogging\nLog each request method and url.\nfunction log_request(stream, next)\n    @info \"request\" stream.message.method stream.message.url\n    next(stream)\nend\n\n# don't forget to register the middleware\napp.middleware[\"**\"] = [log_request]\n\n\nTime\nThe handler bellow logs the time taken to call the next handlers in the chain.\nfunction time_taken(stream, next)\n    x = now()\n    next(stream)\n    elapsed = now() - x\n    @info \"$(stream.message.target) took $elapsed\" \nend\n\n# make sure the middleware is first so\n# we measure the time of all the  downstream handlers\napp.middleware[\"**\"] = [time_taken, ...other_middleware]\n\n\nAuthentication\nFor example authentication might look something like this\nfunction authentication(stream, next)\n    headers = Bonsai.read(\n        stream,\n        Header(x_password=String)\n    )\n\n    if headers.x_password != \"secret_password\"\n        return Bonsai.write(stream, Status(403), Body(\"Forbidden\"))\n    else\n        next(stream)\n    end\nend\n\nfunction protected_route(stream, next)\n    return Bonsai.write(stream, Body(\"Welcome to the club\"))\nend\n\nfunction unproteced_route(stream, next)\n    return Bonsai.write(stream, Body(\"Welcome to the club\"))\nend\n\napp.middleware[\"/protected/**\"] = [authentication]\napp.get[\"/protected/\"] = protected_route\napp.get[\"/\"] = unproteced_route\nTODO: proper example using JWTs.\n\n\nCORS\nThe bellow middleware will accept CORS request from any domain and HTTP method. You can restrict it to specific domains by changing the relevant header e.g \"Access-Control-Allow_Origin\" => \"https://my-website.com\". For more information on CORS see https://cors-errors.info/\nfunction cors(stream::Stream, next)\n    res = stream.message.response\n\n    if stream.message.method == \"OPTIONS\"\n        headers = [\n            \"Access-Control-Allow-Origin\" => \"*\",\n            \"Access-Control-Allow-Headers\" => \"*\",\n            \"Access-Control-Allow-Methods\" => \"*\",\n        ]\n        for i in headers\n            HTTP.setheader(res, i)\n        end\n    else\n        headers = [\n            \"Access-Control-Allow-Origin\" => \"*\",\n        ]\n        for i in headers\n            HTTP.setheader(res, i)\n        end\n        next(stream)\n    end\nend\n\napp.middleware[\"**\"] = [authentication]\nNote you probably don’t want to use a wildcard * for your origin but rather something more specific."
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Bellow are various examples and short snippets of code.\n\n\nA web sockets can be obtained using ws_upgrade, bellow is an example of a echo socket.\napp.get[\"/ws\"] = function(stream)\n    ws_upgrade(stream) do ws\n        for msg in ws\n            @info msg\n            send(ws, msg)\n        end\n    end\nend"
  },
  {
    "objectID": "open_api.html",
    "href": "open_api.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Open API Generation\nAn open api spec can be generated for your App, JET is used to analyze the code and detects all of the Bonsai.read and Bonsai.write calls, this information is then used to create the spec. This feature is currently still alpha and needs some more work before it’s robust.\nopen_api = OpenApi(app)\nJSON3.write(\"open-api.json\", open_api)\nTo add a web page for you documentation you can call\nopenapi!(app)\nThis will add to endpoints:\n\ndocs/ - A web page containing documentation for for API built using SwaggerUI\ndocs/open-api.json - The open API specifcation\n\n\n\nClient Generation\nYou can generate clients from a number of tools from open specs, for example to generate a typescript client you coult run\nnpx openapi-typescript-codegen --input open-api.json --output client"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Intro\nThe following code snippet gets at the essence of the framework\nusing Bonsai\n\nconst app = App()\n\n# our index handler\nfunction index(stream::HTTP.Stream)\n    query = Bonsai.read( stream, Query(name=Union{String, Nothing}))\n    name = isnothing(query.name) ? \"John Doe\" : query.name  \n    Bonsai.write(stream, Body(\"Hi, $name\"))\nend\n\n# register handler\napp.get[\"/\"] = index\n\nstart(app, port=9091)\nThe package provides abstraction so we can treat the HTTP.Stream like IO, declaratively reading and writing from it using types to specify what data we input and output.\n\n\nFeatures\nSome features include:\n\nLive Reloading\nWebSockets\nTight intergration with StructTypes\nFlexiable Middleware\nOpenAPI Support\n\nIf you prefer learning thought reading code checkout the examples or for a more detailed breakdown read the handlers section.\n\n\nAbout\nBonsai aims to be minimalistic and not impose a specific structure on the developer, the API is inspired by FastAPI, Fibre and Express."
  },
  {
    "objectID": "handlers.html",
    "href": "handlers.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Handlers\nEach handler is a function with the signature f(stream::HTTP.Stream). You read and write from the http stream using Bonsai.read or Bonsai.write along with a wrapper type (Body, Query, Headers, Route and Status) to specify the location. The data type being read / written should be a AbstractDict, NamedTuple or have a StructType defined. Both read and write support variadic arguments e.g fn(stream, args...)\n\n\nBody\nBellow is an example of reading reading JSON from a request, and then writing it back as a response\n\napp.get[\"/\"] = function(stream)\n    payload = Bonsai.read(stream, Body(x=Int, y=Float64, z=String))\n    # typeof(payload)\n    # NamedTuple{(:x, :y, :z), Tuple{Int64, Float64, String}}\n    Bonsai.write(stream, Body(payload))\nend\nBonsai.write will attempt to set the correct content-type header for the data, however this can be changed by defining mime_type.\nBonsai.mime_type(::MyType) = \"text/plain\"\nThe content type is defined for the following types already\n\nUnion{NamedTuple, AbstractDict} - application/json\nAbstractString - text/plain\nAbstractPath - Based on the file extension.\n\n\n\nStatus Codes\nThe default status code is 200, however other status codes can be returned by using Status\napp.post[\"/\"] = function(stream)\n    #...first part of handler\n    Bonsai.write(stream, Body(\"Created\"), Status(201))\nend\n\n\nRouting\nRouting relies on the router from HTTP.jl, as such the functionality is the same (see the copied doc stings bellow).\nThe following path types are allowed for matching:\n\n/api/widgets - exact match of static strings\n/api/*/owner - single * to wildcard match any string for a single segment\n/api/widget/{id} - Define a path variable id that matches any valued provided for this segment; path variables are available in the request context like req.context[:params][\"id\"]\n/api/widget/{id:[0-9]+} - Define a path variable id that only matches integers for this segment\n/api/**- double wildcard matches any number of trailing segments in the request path; must be the last segment in the path\n\nYou can extract the route parmeters using the Route type, which will return a named tuple.\napp.get[\"/{id}\"] = function(stream)\n    (;id) = Bonsai.read(stream, Route(id=String))\nend\nThe Route constructor takes the parameter name and the type, multiple keyword arguments are supported.\n\n\nQuery\nFollowing the a similar pattern as the others query parameters can be matched by using Query type.\napp.get[\"/car/\"] = function(stream)\n    (;color) = Bonsai.read(\n        stream, \n        Query(color = Union{Nothing, String}),\n    )\nend\nNote to handle optional parameters you can use a union with nothing e.g Union{Nothing, T}.\n\n\nHeaders\nUse Headers to read and write specific headers. For example a handler that can return either CSV or JSON data might look like.\napp.get[\"/\"] = function(stream)\n    headers = Bonsai.read(stream, Headers(content_type=String))\n    if headers.content_type == \"application/json\"\n        Bonsai.write(\n            stream, \n            Body(json_data),\n            Headers(content_type=\"application/json\")\n        )\n    else\n        Bonsai.write(\n            stream, \n            Body(csv_data),\n            Headers(content_type=\"text/csv\")\n\n        )\n    end\nend\nFor Headers the keys will be transformed using Bonsai.headerize and the matching is case insensitive.\nBonsai.headerize(:content_type)\n# \"content-type\"\n\n\nFiles\nWriting files supports AbstractPaths defined in FilePaths. The content type will be set based on the file extension.\nfile =  Path(\"data/some-file.json\")\nBonsai.write(stream, Body(file))\nA nice feature of this is we can easily use other AbstractPath implementations for example like that in AWSS3\nfile = S3Path(\"s3://my.bucket/test1.txt\") \nBonsai.write(stream, Body(file))"
  }
]