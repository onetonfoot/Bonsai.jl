[
  {
    "objectID": "middleware.html",
    "href": "middleware.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Middleware\nMiddleware is a function of the form f(stream::HTTP.Stream, next), where next is the following handler/middleware in the list. It’s called in the order it was added, with the matching handler (if any) called last. By default app.middleware will run on all request methods however you can specify a specific method with app.middleware.get Bellow are examples of common use cases for middleware\n\n\nLogging\nLog each request method and URL.\nfunction log_request(stream, next)\n    @info \"request\" stream.message.method stream.message.url\n    next(stream)\nend\n\n# don't forget to register the middleware\napp.middleware[\"**\"] = [log_request]\n\n\nTime\nThe handler below logs the time taken to call the next handlers in the chain.\nfunction time_taken(stream, next)\n    x = now()\n    next(stream)\n    elapsed = now() - x\n    @info \"$(stream.message.target) took $elapsed\" \nend\n\n# make sure the middleware is first so\n# we measure the time of all the  downstream handlers\napp.middleware[\"**\"] = [time_taken, ...other_middleware]\n\n\nAuthentication\nFor example, authentication might look something like this\nfunction authentication(stream, next)\n    headers = Bonsai.read(\n        stream,\n        Header(x_password=String)\n    )\n\n    if headers.x_password != \"secret_password\"\n        return Bonsai.write(stream, Status(403), Body(\"Forbidden\"))\n    else\n        next(stream)\n    end\nend\n\nfunction protected_route(stream, next)\n    return Bonsai.write(stream, Body(\"Welcome to the club\"))\nend\n\nfunction unproteced_route(stream, next)\n    return Bonsai.write(stream, Body(\"Welcome to the club\"))\nend\n\nfunction register_middleware!(app)\n    app.middleware[\"/protected/**\"] = [authentication]\n    app.get[\"/protected/\"] = protected_route\n    app.get[\"/\"] = unproteced_route\nend\nTODO: a proper example using JWTs.\n\n\nCORS\nThe below middleware will accept CORS requests from any domain and HTTP method. You can restrict it to specific domains by changing the relevant header e.g \"Access-Control-Allow_Origin\" => \"https://my-website.com\". For more information on CORS see https://cors-errors.info/\nfunction cors(stream::Stream, next)\n    res = stream.message.response\n\n    if stream.message.method == \"OPTIONS\"\n        headers = [\n            \"Access-Control-Allow-Origin\" => \"*\",\n            \"Access-Control-Allow-Headers\" => \"*\",\n            \"Access-Control-Allow-Methods\" => \"*\",\n        ]\n        for i in headers\n            HTTP.setheader(res, i)\n        end\n    else\n        headers = [\n            \"Access-Control-Allow-Origin\" => \"*\",\n        ]\n        for i in headers\n            HTTP.setheader(res, i)\n        end\n        next(stream)\n    end\nend\n\nfunction register_middleware!(app)\n    # runs on all routes\n    app.middleware[\"**\"] = [authentication]\nend\nNote you probably don’t want to use a wildcard * for your origin but rather something more specific."
  },
  {
    "objectID": "examples.html",
    "href": "examples.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Bellow are various examples and short snippets of code.\n\n\nA web sockets can be obtained using ws_upgrade, bellow is an example of a echo socket.\napp.get[\"/ws\"] = function(stream)\n    ws_upgrade(stream) do ws\n        for msg in ws\n            @info msg\n            send(ws, msg)\n        end\n    end\nend"
  },
  {
    "objectID": "open_api.html",
    "href": "open_api.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Open API Generation\nAn open API spec can be generated for your App, JET is used to analyze the code and detects all of the Bonsai.read and Bonsai.write calls, this information is then used to create the spec. This feature is currently still alpha and needs some more work before it’s robust.\nopen_api = OpenApi(app)\nJSON3.write(\"open-api.json\", open_api)\nTo add a web page for your documentation you can call\nopenapi!(app)\nThis will add the endpoints:\n\ndocs/ - A web page containing documentation for API built using SwaggerUI\ndocs/open-api.json - The open API specifcation\n\n\n\nClient Generation\nYou can generate clients using a number of tools from open-api specs, for example, to generate a typescript client you could run\nnpx openapi-typescript-codegen --input open-api.json --output client"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Intro\nThe following code snippet gets at the essence of the framework\nusing Bonsai, HTTP\n\nconst app = App()\n\nfunction index(stream::HTTP.Stream)\n    query = Bonsai.read( stream, Query(name=Union{String, Nothing}))\n    name = isnothing(query.name) ? \"John Doe\" : query.name  \n    Bonsai.write(stream, Body(\"Hi, $name\"))\nend\n\nfunction register_handlers!(app)\n    app.get[\"/\"] = index\nend\n\nfunction run()\n    register_handlers!(app)\n    start(app, port=9091)\nend\n\nrun()\nThe package provides abstraction so we use the HTTP.Stream IO type to declaratively read and write data by specifying our inputs and outputs as types. Calls to Bonsai.read will extract data from the HTTP Request and likewise those to Bonsai.write will construct an HTTP response.\n\n\nFeatures\nSome features include:\n\nLive Reloading (using Revise)\nWebSockets\nTight integration with StructTypes\nFlexible Middleware\nAutomatic OpenAPI Generetation using JET\n\nFor a more detailed breakdown read the handlers section or if you prefer to dive in check out the examples.\n\n\nAbout\nBonsai aims to be minimalistic and not impose a specific structure on the developer, the API is inspired by FastAPI, Fibre and Express."
  },
  {
    "objectID": "handlers.html",
    "href": "handlers.html",
    "title": "Bonsai.jl",
    "section": "",
    "text": "Handlers\nEach handler is a function with the signature f(stream::HTTP.Stream). You read and write from the HTTP stream using Bonsai.read or Bonsai.write along with a wrapper type (Body, Query, Headers, Route and Status) to specify the location. The data type being read/written should be an AbstractDict, NamedTuple or have a StructType defined. Both read and write support variadic arguments e.g fn(stream, args...)\n\n\nBody\nBelow is an example of reading JSON from a request, and then writing it back as a response\nfunction get_index(stream)\n    payload = Bonsai.read(stream, Body(x=Int, y=Float64, z=String))\n    # typeof(payload)\n    # NamedTuple{(:x, :y, :z), Tuple{Int64, Float64, String}}\n    Bonsai.write(stream, Body(payload))\nend\nBonsai.write will attempt to set the correct content-type header for the data, however, this can be changed by defining mime_type.\nBonsai.mime_type(::Type{MyType}) = \"text/plain\"\nThe content type is defined for the following types already\n\nUnion{NamedTuple, AbstractDict} - application/json\nAbstractString - text/plain\nAbstractPath - Based on the file extension.\n\n\n\nStatus Codes\nThe default status code is 200, however other status codes can be returned by using Status\nfunction post_index(stream)\n    #...first part of handler\n    Bonsai.write(stream, Body(\"Created\"), Status(201))\nend\n\n\nRouting\nRouting relies on the router from HTTP.jl, as such the functionality is the same (see the copied doc stings below).\nThe following path types are allowed for matching:\n\n/api/widgets - exact match of static strings\n/api/*/owner - single * to wildcard match any string for a single segment\n/api/widget/{id} - Define a path variable id that matches any value provided for this segment; path variables are available in the request context like req.context[:params][\"id\"]\n/api/widget/{id:[0-9]+} - Define a path variable id that only matches integers for this segment\n/api/**- double wildcard matches any number of trailing segments in the request path; must be the last segment in the path\n\nTo register a route use the dot syntax to specify the HTTP Method and then dictionary indexing for the requested route. e.g\napp.post[\"/pet/{id}\"]\nYou can extract the route parameters using the Route type, which will return a named tuple.\n\nfunction get_by_id(stream)\n    (;id) = Bonsai.read(stream, Route(id=String))\nend\n\napp.get[\"/{id}\"] = get_by_id\nThe Route constructor takes the parameter name and the type. Multiple keyword arguments are supported\n\n\nQuery\nFollowing a similar pattern as the others, query parameters can be matched by using Query type.\n\nfunction get_car(stream)\n    (;color) = Bonsai.read(\n        stream, \n        #/<some route>?color=blue\n        Query(color = Union{Nothing, String}),\n    )\nend\nNote to handle optional parameters you can use a union with nothing e.g Union{Nothing, T}.\n\n\nHeaders\nUse Headers to read and write specific headers. For example, a handler that can return JSON or a CSV depending on the content type header.\n\nfunction index(stream)\n    headers = Bonsai.read(stream, Headers(content_type=String))\n    if headers.content_type == \"application/json\"\n        Bonsai.write(\n            stream, \n            Body(json_data),\n            Headers(content_type=\"application/json\")\n        )\n    else\n        Bonsai.write(\n            stream, \n            Body(csv_data),\n            Headers(content_type=\"text/csv\")\n        )\n    end\nend\nFor Headers the keys will be transformed using Bonsai.headerize and the matching is case-insensitive.\nBonsai.headerize(:content_type)\n# \"content-type\"\n\n\nFiles\nWriting files supports AbstractPaths defined in FilePaths. The content type will be set based on the file extension.\nfile =  Path(\"data/some-file.json\")\nBonsai.write(stream, Body(file))\nA nice feature of this is we can easily use other AbstractPath implementations for example like that in AWSS3\nfile = S3Path(\"s3://my.bucket/test1.txt\") \nBonsai.write(stream, Body(file))\n\n\nJSON\nBecause working with JSON is so common there is a @data macro that can help you define structs for it. This macro supports Base.@kwdef and @composite, for example.\nusing Dates, UUIDs, Bonsai, StructTypes\nusing Bonsai: @data\n\n@data struct BaseModel\n    id::UUID = uuid4()\n    created::Date = now()\n    updated::Date = now()\nend\n\n\n\"\"\"\nMarkdown documentation included in OpenAPI description\n\n* name - first and last name\n\"\"\"\n@data struct Person\n    BaseModel...\n    name::String\nend\nThis expands to roughly the following source code\n\nBase.@kwdef struct Person\n    # Note splatted fields from BaseModel \n    id::UUID = uuid4()\n    created::Date = now()\n    updated::Date = now()\n    name::String \nend\n\n# Allows struct to be correctly read from JSON\nStructTypes.StructType(::Type{Person}) = StructTypes.Struct()\n# Set the correct description to be used in OpenAPI docs\nBonsai.description(t::Type{Person}) = Bonsai.docstr(t)\nTo help with generating boilerplate you can use JSON3.generatedtypes."
  }
]